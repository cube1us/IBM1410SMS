/* 
 *  COPYRIGHT 2018, 2019, 2020 Jay R. Jaeger
 *  
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  (file COPYING.txt) along with this program.  
 *  If not, see <https://www.gnu.org/licenses/>.
*/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace IBM1410SMS
{
    class GenerateGroupHDLLogicVHDL : GenerateGroupHDLLogic
    {

        string bufferPrefix = "XX_";

        public override string generateHDLExtension() {
            return ("vhdl");
        }

        //  Class to generate HDL prefix information - standard intro comments,
        //  library declarations, etc.

        public override void generateHDLPrefix(string name, string machineName) {
            outFile.WriteLine("-- VHDL for IBM SMS ALD group " + name);
            outFile.WriteLine("-- Title: " + name);
            outFile.WriteLine("-- IBM Machine Name " + machineName);
            outFile.WriteLine("-- Generated by GenerateHDL");
            outFile.WriteLine();
            outFile.WriteLine("library IEEE;");
            outFile.WriteLine("use IEEE.STD_LOGIC_1164.ALL;");
            outFile.WriteLine();
            outFile.WriteLine("library xil_defaultlib;");
            outFile.WriteLine("use xil_defaultlib.all;");
            outFile.WriteLine();
        }

        public override void generateHDLentity(
            string entityName, List<string> inputs, List<string> outputs) {

            outFile.WriteLine("entity " + entityName + " is");
            outFile.WriteLine("\tPort (");
            outFile.Write("\t\t" + SystemClockName + ": in STD_LOGIC");
            foreach(string signal in inputs) {
                outFile.Write(";" + Environment.NewLine + "\t\t" +
                    generateSignalName(signal) + ": in STD_LOGIC");
            }
            foreach(string signal in outputs) {
                outFile.Write(";" + Environment.NewLine + "\t\t" +
                    generateSignalName(signal) + ": out STD_LOGIC");
            }
            outFile.WriteLine(");");
            outFile.WriteLine("end " + entityName + ";");
        }

        public override void generateHDLArchitecturePrefix(string name) {
            outFile.WriteLine();
            outFile.WriteLine("ARCHITECTURE structural of " + name + " is");
        }

        public override void generateHDLSignalList(
            List<string> signals, List<string> bufferSignals) {
            outFile.WriteLine();
            foreach(string signal in signals) {
                outFile.WriteLine("\t signal " +
                    generateSignalName(signal) + ": STD_LOGIC;");
            }
            if (signals.Count > 0) {
                outFile.WriteLine();
            }

            //  Since we are generating VHDL, also generate a signal for
            //  anything that appears as an output in the port map, but is
            //  also used internally.

            foreach(string signal in bufferSignals) {
                outFile.WriteLine("\t signal " + bufferPrefix +
                    generateSignalName(signal) + ": STD_LOGIC;");
            }
            if(bufferSignals.Count > 0) {
                outFile.WriteLine();
            }

            outFile.WriteLine("BEGIN");
            outFile.WriteLine();

            //  Now we also generate assignments for the buffer signals...

            foreach(string signal in bufferSignals) {
                outFile.WriteLine("\t" + generateSignalName(signal) + " <= ");
                outFile.WriteLine("\t\t" + bufferPrefix + generateSignalName(signal) +
                    ";");
            }
            if(bufferSignals.Count > 0) {
                outFile.WriteLine();
            }
        }

        public override void generateHDLArchitectureSuffix() {
            outFile.WriteLine();
            outFile.WriteLine("END;");
        }

        public override void generatePageEntity(string pageName, string pageTitle, 
            List<string> inputs, List<string> outputs, List<string> bufferSignals,
            bool needsClock) {

            bool firstPort = true;

            outFile.WriteLine("Page_" +
                replacePeriods.Replace(pageName, "_") + ": ENTITY " +
                generateHDLEntityName(pageName, pageTitle));
            outFile.WriteLine("   PORT MAP (");

            if(needsClock) {
                outFile.Write("\t" + SystemClockName + " => " +
                    SystemClockName);
                firstPort = false;
            }

            foreach(string input in inputs) {
                if(!firstPort) {
                    outFile.WriteLine(",");
                }
                outFile.WriteLine("\t" + generateSignalName(input) + " =>");
                outFile.Write("\t\t" + 
                    (bufferSignals.Contains(input) ? bufferPrefix : "") +
                    generateSignalName(input));
                firstPort = false;
            }

            foreach (string output in outputs) {
                if (!firstPort) {
                    outFile.WriteLine(",");
                }
                outFile.WriteLine("\t" + generateSignalName(output) + " =>");
                outFile.Write("\t\t" +
                    (bufferSignals.Contains(output) ? bufferPrefix : "") +
                    generateSignalName(output));
                firstPort = false;
            }

            outFile.WriteLine();
            outFile.WriteLine("\t);");
            outFile.WriteLine();
        }
    }
}
